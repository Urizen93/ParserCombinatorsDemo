@using System.Reactive.Disposables
@using System.Reactive.Linq
@using DynamicData.Binding
@using Unit = System.Reactive.Unit
@implements IDisposable

<UserFilter ViewModel="@ViewModel.Filter"></UserFilter>

<MudTable
    Items="@ViewModel.Users"
    Hover="true"
    Breakpoint="Breakpoint.Sm"
    Loading="@ViewModel.IsLoading"
    LoadingProgressColor="Color.Info"
    RowClass="cursor-pointer">
    <HeaderContent>
        <MudTh>Name</MudTh>
        <MudTh>Age</MudTh>
        <MudTh>Premium status</MudTh>
        <MudTh>Roles</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="Name">@context.User.Name</MudTd>
        <MudTd DataLabel="Age">@context.User.Age</MudTd>
        <MudTd DataLabel="Premium status">@context.User.IsPremium</MudTd>
        <MudTd DataLabel="Roles">@String.Join(", ", context.User.Roles)</MudTd>
    </RowTemplate>
</MudTable>

@code
{
    private readonly SerialDisposable _serial = new();
    
    [EditorRequired, Parameter]
    public required UsersViewModel ViewModel { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await ViewModel.Refresh();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _serial.Disposable = ViewModel
            .WhenAnyPropertyChanged()
            .Select(_ => Unit.Default)
            .Merge(
                ViewModel.Users
                    .ObserveCollectionChanges()
                    .Select(_ => Unit.Default))
            .Subscribe(_ => StateHasChanged());
    }

    public void Dispose() => _serial.Dispose();
}